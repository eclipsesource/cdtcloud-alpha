[{"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/cpp-debug-frontend-contribution.ts":"1","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/cpp-debug-frontend-module.ts":"2","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/diff-widget/memory-diff-options-widget.tsx":"3","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/diff-widget/memory-diff-select-widget.tsx":"4","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/diff-widget/memory-diff-table-widget.tsx":"5","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/diff-widget/memory-diff-widget-types.ts":"6","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/editable-widget/memory-editable-table-widget.tsx":"7","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/memory-provider/memory-provider.spec.ts":"8","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/memory-provider/memory-provider.ts":"9","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/memory-widget/memory-options-widget.tsx":"10","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/memory-widget/memory-table-widget.tsx":"11","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/memory-widget/memory-widget.ts":"12","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/register-widget/register-filter-service.ts":"13","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/register-widget/register-options-widget.tsx":"14","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/register-widget/register-table-widget.tsx":"15","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/register-widget/register-widget-types.ts":"16","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-commands.ts":"17","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-hover-renderer.ts":"18","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-recents.ts":"19","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-widget-components.tsx":"20","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-widget-manager.ts":"21","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-widget-utils.tsx":"22","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-widget-variable-utils.ts":"23","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/multi-select-bar.tsx":"24","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/wrapper-widgets/memory-dock-panel.ts":"25","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/wrapper-widgets/memory-dockpanel-placeholder-widget.tsx":"26","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/wrapper-widgets/memory-layout-widget.tsx":"27","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/common/util.ts":"28","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/common/utils.spec.ts":"29","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/node/cpp-debug-backend-contribution.ts":"30","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/node/cpp-debug-backend-module.ts":"31"},{"size":15798,"mtime":1626344567949,"results":"32","hashOfConfig":"33"},{"size":5705,"mtime":1626344567953,"results":"34","hashOfConfig":"33"},{"size":5382,"mtime":1626344567953,"results":"35","hashOfConfig":"33"},{"size":6922,"mtime":1626344567953,"results":"36","hashOfConfig":"33"},{"size":16366,"mtime":1626344567957,"results":"37","hashOfConfig":"33"},{"size":1573,"mtime":1626344567957,"results":"38","hashOfConfig":"33"},{"size":13187,"mtime":1626344567961,"results":"39","hashOfConfig":"33"},{"size":968,"mtime":1626344567961,"results":"40","hashOfConfig":"33"},{"size":3677,"mtime":1626344567961,"results":"41","hashOfConfig":"33"},{"size":28754,"mtime":1626344567965,"results":"42","hashOfConfig":"33"},{"size":25659,"mtime":1626344567965,"results":"43","hashOfConfig":"33"},{"size":4633,"mtime":1626344567969,"results":"44","hashOfConfig":"33"},{"size":2817,"mtime":1626344567969,"results":"45","hashOfConfig":"33"},{"size":14516,"mtime":1626344567973,"results":"46","hashOfConfig":"33"},{"size":11773,"mtime":1626344567973,"results":"47","hashOfConfig":"33"},{"size":2432,"mtime":1626344567977,"results":"48","hashOfConfig":"33"},{"size":2222,"mtime":1626344567985,"results":"49","hashOfConfig":"33"},{"size":4087,"mtime":1626344567989,"results":"50","hashOfConfig":"33"},{"size":2015,"mtime":1626344567989,"results":"51","hashOfConfig":"33"},{"size":6782,"mtime":1626344567989,"results":"52","hashOfConfig":"33"},{"size":6877,"mtime":1626344567989,"results":"53","hashOfConfig":"33"},{"size":4183,"mtime":1626344567993,"results":"54","hashOfConfig":"33"},{"size":8192,"mtime":1626344567993,"results":"55","hashOfConfig":"33"},{"size":2799,"mtime":1626344567993,"results":"56","hashOfConfig":"33"},{"size":2202,"mtime":1626344567997,"results":"57","hashOfConfig":"33"},{"size":1740,"mtime":1626344567997,"results":"58","hashOfConfig":"33"},{"size":6701,"mtime":1626344567997,"results":"59","hashOfConfig":"33"},{"size":1341,"mtime":1626344568001,"results":"60","hashOfConfig":"33"},{"size":1642,"mtime":1626344568001,"results":"61","hashOfConfig":"33"},{"size":3417,"mtime":1626344568001,"results":"62","hashOfConfig":"33"},{"size":1246,"mtime":1626344568005,"results":"63","hashOfConfig":"33"},{"filePath":"64","messages":"65","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"18114fx",{"filePath":"66","messages":"67","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"68","messages":"69","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"70"},{"filePath":"71","messages":"72","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"73"},{"filePath":"74","messages":"75","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"76","messages":"77","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"78","messages":"79","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80"},{"filePath":"81","messages":"82","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"83","messages":"84","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"87"},{"filePath":"88","messages":"89","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"90","messages":"91","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"92","messages":"93","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"94","messages":"95","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"96","messages":"97","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"98"},{"filePath":"99","messages":"100","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"101","messages":"102","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"103","messages":"104","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"105","messages":"106","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"107","messages":"108","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"109","messages":"110","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"111","messages":"112","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"113","messages":"114","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"115","messages":"116","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"117","messages":"118","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"119","messages":"120","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"121","messages":"122","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"123","messages":"124","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"125","messages":"126","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"127","messages":"128","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"129","messages":"130","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/cpp-debug-frontend-contribution.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/cpp-debug-frontend-module.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/diff-widget/memory-diff-options-widget.tsx",["131"],"/********************************************************************************\n * Copyright (C) 2021 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport * as React from 'react';\nimport { injectable, inject, postConstruct } from 'inversify';\nimport { ThemeType } from '@theia/core/lib/browser/theming';\nimport { Key } from '@theia/core/lib/browser';\nimport { Interfaces, MemoryDiffWidgetData, Utils } from '../utils/memory-widget-utils';\nimport { MWInput } from '../utils/memory-widget-components';\nimport { DiffLabels } from './memory-diff-widget-types';\nimport { MemoryOptionsWidget, LOCATION_OFFSET_FIELD_ID, LENGTH_FIELD_ID } from '../memory-widget/memory-options-widget';\n\nexport interface DiffMemoryOptions extends Interfaces.MemoryOptions {\n    beforeOffset: number;\n    afterOffset: number;\n}\n\n@injectable()\nexport class MemoryDiffOptionsWidget extends MemoryOptionsWidget {\n    @inject(MemoryDiffWidgetData) protected memoryWidgetOptions: MemoryDiffWidgetData;\n\n    protected themeType: ThemeType;\n\n    get options(): DiffMemoryOptions {\n        return this.storeState();\n    }\n\n    updateDiffData(newDiffData: Partial<MemoryDiffWidgetData>): void {\n        this.memoryWidgetOptions = { ...this.memoryWidgetOptions, ...newDiffData };\n        this.init();\n    }\n\n    @postConstruct()\n    protected init(): void {\n        this.addClass(MemoryOptionsWidget.ID);\n        this.addClass('diff-options-widget');\n        const { identifier, beforeBytes, afterBytes } = this.memoryWidgetOptions;\n        this.id = `${MemoryDiffOptionsWidget.ID}-${identifier}`;\n        this.title.label = `Diff: ${identifier}`;\n        this.title.caption = this.title.label;\n        this.title.iconClass = this.iconClass;\n        this.title.closable = true;\n\n        this.toDispose.push(this.onOptionsChanged(() => this.update()));\n\n        beforeBytes.label = DiffLabels.Before;\n        afterBytes.label = DiffLabels.After;\n\n        this.columnsDisplayed = {\n            beforeAddress: { label: 'Address', doRender: true },\n            beforeData: { label: this.memoryWidgetOptions.titles[0], doRender: true },\n            afterAddress: { label: 'Address', doRender: true },\n            afterData: { label: this.memoryWidgetOptions.titles[1], doRender: true },\n            variables: { label: 'Variables', doRender: false },\n            ascii: { label: 'ASCII', doRender: false },\n        };\n\n        this.update();\n    }\n\n    protected acceptFocus(): void {\n        const settingsCog = this.node.querySelector('.toggle-settings-click-zone') as HTMLDivElement;\n        settingsCog?.focus();\n    }\n\n    protected renderMemoryLocationGroup(): React.ReactNode {\n        const { titles: [beforeTitle, afterTitle] } = this.memoryWidgetOptions;\n        return (\n            <div className='t-mv-group view-group'>\n                <MWInput\n                    id={LOCATION_OFFSET_FIELD_ID}\n                    label={`${beforeTitle} Offset`}\n                    title={`Bytes to offset the memory from ${beforeTitle}`}\n                    defaultValue='0'\n                    passRef={this.assignOffsetRef}\n                    onChange={Utils.validateNumericalInputs}\n                    onKeyDown={this.doRefresh}\n                />\n                <MWInput\n                    id={LENGTH_FIELD_ID}\n                    label={`${afterTitle} Offset`}\n                    title={`Bytes to offset the memory from ${afterTitle}`}\n                    defaultValue='0'\n                    passRef={this.assignReadLengthRef}\n                    onChange={Utils.validateNumericalInputs}\n                    onKeyDown={this.doRefresh}\n                />\n                <button\n                    type='button'\n                    className='theia-button main view-group-go-button'\n                    onClick={this.doRefresh}\n                >\n                    Go\n                </button>\n            </div>\n        );\n    }\n\n    protected getObligatoryColumnIds(): string[] {\n        return ['beforeAddress', 'beforeData', 'afterAddress', 'afterData'];\n    }\n\n    protected doRefresh = (event: React.KeyboardEvent<HTMLInputElement> | React.MouseEvent<HTMLButtonElement, MouseEvent>): void => {\n        if ('key' in event && event.keyCode !== Key.ENTER.keyCode) {\n            return;\n        }\n        this.fireDidChangeOptions();\n    };\n\n    storeState(): DiffMemoryOptions {\n        return {\n            ...super.storeState(),\n            // prefix a 0. It'll do nothing if it's a number, but if it's an empty string or garbage, it'll make parseInt return 0.\n            beforeOffset: parseInt(`0${this.offsetField?.value ?? 0}`),\n            afterOffset: parseInt(`0${this.readLengthField?.value ?? 0}`),\n        };\n    }\n}\n","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/diff-widget/memory-diff-select-widget.tsx",["132"],"/********************************************************************************\n * Copyright (C) 2021 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport * as React from 'react';\nimport { inject, injectable, postConstruct } from 'inversify';\nimport { Key, Message, ReactWidget } from '@theia/core/lib/browser';\nimport { MWSelect } from '../utils/memory-widget-components';\nimport { MemoryWidgetManager } from '../utils/memory-widget-manager';\nimport { Interfaces } from '../utils/memory-widget-utils';\nimport { VariableRange } from '../utils/memory-widget-variable-utils';\nimport { RegisterWidget } from '../register-widget/register-widget-types';\nimport { MemoryDiffWidget } from './memory-diff-table-widget';\nimport * as Long from 'long';\nimport { MemoryWidget } from '../memory-widget/memory-widget';\n\ninterface DiffMemory {\n    beforeAddress: Long;\n    beforeBytes: Interfaces.LabeledUint8Array;\n    beforeVariables: VariableRange[];\n    afterAddress: Long;\n    afterBytes: Interfaces.LabeledUint8Array;\n    afterVariables: VariableRange[];\n}\n\n@injectable()\nexport class MemoryDiffSelectWidget extends ReactWidget {\n    static DIFF_SELECT_CLASS = 'memory-diff-select';\n\n    protected beforeWidgetLabel = '';\n    protected afterWidgetLabel = '';\n\n    protected labelToWidgetMap = new Map<string, MemoryWidget>();\n\n    @inject(MemoryWidgetManager) protected readonly memoryWidgetManager: MemoryWidgetManager;\n\n    @postConstruct()\n    protected init(): void {\n        this.addClass(MemoryDiffSelectWidget.DIFF_SELECT_CLASS);\n        this.id = MemoryDiffSelectWidget.DIFF_SELECT_CLASS;\n        this.updateWidgetMap();\n        this.update();\n        this.toDispose.push(this.memoryWidgetManager.onChanged(() => this.updateWidgetMap()));\n        this.scrollOptions = { ...this.scrollOptions, suppressScrollX: false };\n        this.hide();\n    }\n\n    onActivateRequest(msg: Message): void {\n        super.onActivateRequest(msg);\n        this.node.querySelector('select')?.focus();\n    }\n\n    protected assignBaseValue = (e: React.ChangeEvent<HTMLSelectElement>): void => {\n        this.beforeWidgetLabel = e.target.value;\n        this.update();\n    };\n\n    protected assignLaterValue = (e: React.ChangeEvent<HTMLSelectElement>): void => {\n        this.afterWidgetLabel = e.target.value;\n        this.update();\n    };\n\n    render(): React.ReactNode {\n        const optionLabels = [...this.labelToWidgetMap.keys()];\n        const currentBase = this.getBeforeLabel(optionLabels);\n        const currentChanged = this.getAfterLabel(optionLabels, currentBase);\n        return optionLabels.length > 1 && (\n            <div className='memory-diff-select-wrapper'>\n                <div className='diff-select-input-wrapper'>\n                    <div className='t-mv-diff-select-widget-options-wrapper'>\n                        <MWSelect\n                            id='diff-selector-before'\n                            label='compare'\n                            value={currentBase}\n                            options={optionLabels}\n                            onChange={this.assignBaseValue}\n                        />\n                    </div>\n                    <div className='t-mv-diff-select-widget-options-wrapper'>\n                        <MWSelect\n                            id='diff-selector-after'\n                            label='with'\n                            value={currentChanged}\n                            options={optionLabels.filter(label => label !== currentBase)}\n                            onChange={this.assignLaterValue}\n                            onKeyDown={this.diffIfEnter}\n                        />\n                    </div>\n                </div>\n                <button\n                    type='button'\n                    className='theia-button main memory-diff-select-go'\n                    onClick={this.diff}\n                >\n                    Go\n                </button>\n            </div>\n        );\n    }\n\n    protected diffIfEnter = (e: React.KeyboardEvent<HTMLInputElement>): void => {\n        if (e.keyCode === Key.ENTER.keyCode) {\n            this.doDiff();\n        }\n    };\n\n    protected updateWidgetMap(): void {\n        const widgets = this.memoryWidgetManager.availableWidgets.filter(widget => !MemoryDiffWidget.is(widget) && !RegisterWidget.is(widget));\n        this.labelToWidgetMap = new Map<string, MemoryWidget>(widgets.map((widget): [string, MemoryWidget] => [widget.title.label, widget]));\n        this.update();\n    }\n\n    protected getBeforeLabel(optionLabels: string[] = [...this.labelToWidgetMap.keys()]): string {\n        return this.labelToWidgetMap.has(this.beforeWidgetLabel) && this.beforeWidgetLabel || optionLabels[0];\n    }\n\n    protected getAfterLabel(optionLabels: string[], beforeWidgetLabel: string = this.getBeforeLabel(optionLabels)): string {\n        return (this.afterWidgetLabel && this.afterWidgetLabel !== beforeWidgetLabel\n            ? this.afterWidgetLabel\n            : optionLabels.find(label => label !== beforeWidgetLabel)) ?? '';\n    }\n\n    protected diff = (): void => this.doDiff();\n\n    protected doDiff(): void {\n        const labels = [...this.labelToWidgetMap.keys()];\n        const baseLabel = this.getBeforeLabel(labels);\n        const changedLabel = this.getAfterLabel(labels, baseLabel);\n        const baseWidget = this.labelToWidgetMap.get(baseLabel);\n        const changedWidget = this.labelToWidgetMap.get(changedLabel);\n        if (baseWidget && changedWidget) {\n            const memoryAndAddresses = this.getMemoryArrays(baseWidget, changedWidget);\n            this.memoryWidgetManager.doDiff({ ...memoryAndAddresses, titles: [baseLabel, changedLabel] });\n        }\n    }\n\n    protected getMemoryArrays(beforeWidget: MemoryWidget, afterWidget: MemoryWidget): DiffMemory {\n        const { memory: beforeMemory } = beforeWidget.optionsWidget;\n        const { memory: afterMemory } = afterWidget.optionsWidget;\n        return {\n            beforeBytes: beforeMemory.bytes,\n            afterBytes: afterMemory.bytes,\n            beforeAddress: beforeMemory.address,\n            afterAddress: afterMemory.address,\n            beforeVariables: beforeMemory.variables,\n            afterVariables: afterMemory.variables,\n        };\n    }\n}\n","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/diff-widget/memory-diff-table-widget.tsx",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/diff-widget/memory-diff-widget-types.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/editable-widget/memory-editable-table-widget.tsx",["133"],"/********************************************************************************\n * Copyright (C) 2021 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { Key, KeyCode } from '@theia/core/lib/browser';\nimport { Deferred } from '@theia/core/lib/common/promise-util';\nimport { injectable, postConstruct } from 'inversify';\nimport * as React from 'react';\nimport { MemoryTableWidget, MemoryTable } from '../memory-widget/memory-table-widget';\nimport { EasilyMappedObject } from '../utils/memory-hover-renderer';\nimport { Interfaces } from '../utils/memory-widget-utils';\nimport * as Long from 'long';\nimport { hexStrToUnsignedLong } from '../../common/util';\nimport { MemoryWidget } from '../memory-widget/memory-widget';\nimport { MemoryOptionsWidget } from '../memory-widget/memory-options-widget';\n\nexport type EditableMemoryWidget = MemoryWidget<MemoryOptionsWidget, MemoryEditableTableWidget>;\nexport namespace EditableMemoryWidget {\n    export const ID = 'editable.memory.widget';\n}\n\n@injectable()\nexport class MemoryEditableTableWidget extends MemoryTableWidget {\n    protected pendingMemoryEdits = new Map<Long, string>();\n    protected previousBytes: Interfaces.LabeledUint8Array | undefined;\n    protected memoryEditsCompleted = new Deferred<void>();\n    protected highlightedField: Long = Long.fromInt(-1);\n\n    protected doShowMoreMemoryBefore = false;\n    protected doShowMoreMemoryAfter = false;\n\n    @postConstruct()\n    protected async init(): Promise<void> {\n        this.memoryEditsCompleted.resolve();\n        await super.init();\n    }\n\n    resetModifiedValue(valueAddress: Long): void {\n        const didChange = this.pendingMemoryEdits.delete(valueAddress);\n        if (didChange) {\n            this.update();\n        }\n    }\n\n    protected getState(): void {\n        super.getState();\n        if (!this.isInBounds(this.highlightedField)) {\n            this.highlightedField = this.memory.address;\n        }\n    }\n\n    protected async handleMemoryChange(newMemory: Interfaces.MemoryReadResult): Promise<void> {\n        await this.memoryEditsCompleted.promise;\n        this.pendingMemoryEdits.clear();\n        super.handleMemoryChange(newMemory);\n    }\n\n    protected areSameRegion(a: Interfaces.MemoryReadResult, b?: Interfaces.MemoryReadResult): boolean {\n        return a.address === b?.address && a.bytes.length === b.bytes.length;\n    }\n\n    protected getTableFooter(): React.ReactNode {\n        return (\n            !!this.pendingMemoryEdits.size && (\n                <div className='memory-edit-button-container'>\n                    <button\n                        className='theia-button secondary'\n                        onClick={this.handleClearEditClick}\n                        type='reset'\n                    >\n                        Clear Changes\n                    </button>\n                    <button\n                        className='theia-button main'\n                        onClick={this.submitMemoryEdits}\n                        type='submit'\n                    >\n                        Apply Changes\n                    </button>\n                </div>)\n        );\n    }\n\n    protected getBitAttributes(arrayOffset: number, iteratee: Interfaces.LabeledUint8Array): Partial<Interfaces.FullNodeAttributes> {\n        const attributes = super.getBitAttributes(arrayOffset, iteratee);\n        const classNames = attributes.className?.split(' ') ?? [];\n        const itemID = this.memory.address.add(arrayOffset);\n        const isHighlight = itemID === this.highlightedField;\n        const isEditPending = this.pendingMemoryEdits.has(itemID);\n        const padder = isHighlight && isEditPending ? '\\xa0' : '0'; // non-breaking space so it doesn't look like plain whitespace.\n        const stringValue = (this.pendingMemoryEdits.get(itemID) ?? this.memory.bytes[arrayOffset].toString(16)).padStart(2, padder);\n        if (!this.options.isFrozen) {\n            if (isHighlight) {\n                classNames.push('highlight');\n            }\n            if (isEditPending) {\n                classNames.push('modified');\n            }\n        }\n        return {\n            ...attributes,\n            className: classNames.join(' '),\n            content: stringValue\n        };\n    }\n\n    protected getHoverForChunk(span: HTMLElement): EasilyMappedObject | undefined {\n        const addressAsString = span.getAttribute('data-id');\n        if (addressAsString) {\n            const address = hexStrToUnsignedLong(addressAsString);\n            const { value } = this.composeByte(address, true);\n            const { value: inMemory } = this.composeByte(address, false);\n            const oldValue = this.previousBytes && this.composeByte(address, false, this.previousBytes).value;\n            const decimal = parseInt(value, 16);\n            const octal = decimal.toString(8).padStart(this.options.byteSize / 8, '0');\n            const UTF8 = String.fromCharCode(decimal);\n            const binary = this.getPaddedBinary(decimal);\n            const toSend: EasilyMappedObject = { hex: value, octal, binary, decimal };\n            if (UTF8) {\n                toSend.UTF8 = UTF8;\n            }\n            if (inMemory !== value) {\n                toSend['Current Value'] = inMemory;\n            }\n            if (oldValue !== undefined && oldValue !== value) {\n                toSend['Previous Value'] = oldValue;\n            }\n            return toSend;\n        }\n        return undefined;\n    }\n\n    protected composeByte(\n        addressPlusArrayOffset: Long,\n        usePendingEdits: boolean,\n        dataSource: Uint8Array = this.memory.bytes,\n    ): Interfaces.ByteFromChunkData {\n        let value = '';\n\n        const offset = addressPlusArrayOffset.subtract(this.memory.address);\n        const chunksPerByte = this.options.byteSize / 8;\n        const startingChunkIndex = offset.subtract(offset.modulo(chunksPerByte));\n        const address = this.memory.address.add(startingChunkIndex.multiply(8 / this.options.byteSize));\n\n        for (let i = 0; i < chunksPerByte; i += 1) {\n            const targetOffset = startingChunkIndex.add(i);\n            const targetChunk = this.getFromMapOrArray(targetOffset, usePendingEdits, dataSource);\n            value += targetChunk.padStart(2, '0');\n        }\n\n        return { address, value };\n    }\n\n    protected getFromMapOrArray(arrayOffset: Long, usePendingEdits: boolean, dataSource: Uint8Array = this.memory.bytes): string {\n        let value = usePendingEdits ? this.pendingMemoryEdits.get(arrayOffset.add(this.memory.address)) : undefined;\n        if (value === undefined) {\n            value = dataSource[arrayOffset.toInt()]?.toString(16) ?? '';\n        }\n        return value;\n    }\n\n    protected handleClearEditClick = (): void => this.clearEdits();\n\n    protected clearEdits(address?: Long): void {\n        if (typeof address === 'number') {\n            this.pendingMemoryEdits.delete(address);\n        } else {\n            this.pendingMemoryEdits.clear();\n        }\n        this.update();\n    }\n\n    protected submitMemoryEdits = async (): Promise<void> => {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        for await (const _ of this.submitMemoryEditInOrder()) {\n            // Do nothing, but without lint errors.\n        }\n    };\n\n    private * submitMemoryEditInOrder(): IterableIterator<Promise<void>> {\n        this.memoryEditsCompleted = new Deferred();\n        const addressesSubmitted = new Set<Long>();\n        for (const address of this.pendingMemoryEdits.keys()) {\n            const { address: addressToSend, value: valueToSend } = this.composeByte(address, true);\n            if (!addressesSubmitted.has(addressToSend)) {\n                yield this.memoryProvider.writeMemory?.(addressToSend.toString(), valueToSend) ?? Promise.resolve();\n                addressesSubmitted.add(addressToSend);\n            }\n        }\n        this.memoryEditsCompleted.resolve();\n    }\n\n    protected getWrapperHandlers(): MemoryTable.WrapperHandlers {\n        return this.options.isFrozen\n            ? super.getWrapperHandlers()\n            : {\n                onClick: this.handleTableClick,\n                onContextMenu: this.handleTableRightClick,\n                onKeyDown: this.handleTableInput,\n                onMouseMove: this.handleTableMouseMove,\n            };\n    }\n\n    private handleTableClick = (event: React.MouseEvent): void => {\n        const target = event.target as HTMLElement;\n        if (target.classList?.contains('eight-bits')) {\n            this.highlightedField = hexStrToUnsignedLong(target.getAttribute('data-id') ?? '0x-1');\n            this.update();\n            event.stopPropagation();\n        }\n    };\n\n    protected doHandleTableRightClick(event: React.MouseEvent): void {\n        const target = event.target as HTMLElement;\n        if (target.classList?.contains('eight-bits')) {\n            this.highlightedField = hexStrToUnsignedLong(target.getAttribute('data-id') ?? '0x-1');\n        }\n        super.doHandleTableRightClick(event);\n    }\n\n    // eslint-disable-next-line max-lines-per-function,complexity\n    private handleTableInput = (event: React.KeyboardEvent): void => {\n        if (this.highlightedField.lessThan(0)) {\n            return;\n        }\n        const { keyCode } = event;\n        const initialHighlight = this.highlightedField;\n        const initialHighlightIndex = initialHighlight.subtract(this.memory.address);\n        if (keyCode === Key.TAB.keyCode) {\n            return;\n        }\n        const arrayElementsPerRow = (this.options.byteSize / 8) * this.options.bytesPerGroup * this.options.groupsPerRow;\n        const isAlreadyEdited = this.pendingMemoryEdits.has(this.highlightedField);\n        const oldValue = this.pendingMemoryEdits.get(initialHighlight) ??\n            this.memory.bytes[initialHighlightIndex.toInt()].toString(16).padStart(2, '0');\n        let possibleNewHighlight = new Long(-1);\n        let newValue = oldValue;\n        switch (keyCode) {\n            case Key.ARROW_DOWN.keyCode:\n                possibleNewHighlight = initialHighlight.add(arrayElementsPerRow);\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n            case Key.ARROW_UP.keyCode:\n                possibleNewHighlight = initialHighlight.greaterThan(arrayElementsPerRow) ? initialHighlight.subtract(arrayElementsPerRow) : possibleNewHighlight;\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n            case Key.ARROW_RIGHT.keyCode:\n                possibleNewHighlight = initialHighlight.add(1);\n                event.preventDefault();\n                event.stopPropagation();\n                break;\n            case Key.ARROW_LEFT.keyCode:\n                possibleNewHighlight = initialHighlight.greaterThan(0) ? initialHighlight.subtract(1) : possibleNewHighlight;\n                break;\n            case Key.BACKSPACE.keyCode:\n                newValue = oldValue.slice(0, oldValue.length - 1);\n                break;\n            case Key.DELETE.keyCode:\n                newValue = '';\n                break;\n            case Key.ENTER.keyCode:\n                this.submitMemoryEdits();\n                break;\n            case Key.ESCAPE.keyCode:\n                if (isAlreadyEdited) {\n                    this.clearEdits(this.highlightedField);\n                } else {\n                    this.clearEdits();\n                }\n                break;\n            default: {\n                const keyValue = parseInt(KeyCode.createKeyCode(event.nativeEvent).toString(), 16);\n                if (!Number.isNaN(keyValue)) {\n                    newValue = isAlreadyEdited ? oldValue : '';\n                    if (newValue.length < 2) {\n                        newValue += keyValue.toString(16);\n                    }\n                }\n            }\n        }\n        if (this.isInBounds(possibleNewHighlight)) {\n            this.highlightedField = possibleNewHighlight;\n        }\n        const valueWasChanged = newValue !== oldValue;\n        if (valueWasChanged) {\n            this.pendingMemoryEdits.set(this.highlightedField, newValue);\n        }\n        if (valueWasChanged || this.highlightedField !== initialHighlight) {\n            this.update();\n        }\n    };\n\n    private isInBounds(candidateAddress: Long): boolean {\n        const { address, bytes } = this.memory;\n        return candidateAddress.greaterThanOrEqual(address) &&\n            candidateAddress.lessThan(address.add(bytes.length));\n    }\n}\n","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/memory-provider/memory-provider.spec.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/memory-provider/memory-provider.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/memory-widget/memory-options-widget.tsx",["134","135","136","137"],"/********************************************************************************\n * Copyright (C) 2021 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/* eslint-disable no-bitwise, max-lines */\n\nimport * as React from 'react';\nimport { inject, injectable, postConstruct } from 'inversify';\nimport { Message, ReactWidget, StatefulWidget, Key } from '@theia/core/lib/browser';\nimport { debounce } from 'lodash';\nimport { Disposable, DisposableCollection, Emitter } from '@theia/core';\nimport { DebugSessionManager } from '@theia/debug/lib/browser/debug-session-manager';\nimport { DebugSession, DebugState } from '@theia/debug/lib/browser/debug-session';\nimport { Deferred } from '@theia/core/lib/common/promise-util';\nimport * as Long from 'long';\nimport { MemoryProvider } from '../memory-provider/memory-provider';\nimport { Recents } from '../utils/memory-recents';\nimport { MWSelect, MWInputWithSelect, MWInput } from '../utils/memory-widget-components';\nimport { Interfaces, MemoryWidgetOptions, Utils, Constants } from '../utils/memory-widget-utils';\nimport { VariableRange, getLocals } from '../utils/memory-widget-variable-utils';\nimport { MWMultiSelect, SingleSelectItemProps } from '../utils/multi-select-bar';\n\nexport const EMPTY_MEMORY: Interfaces.MemoryReadResult = {\n    bytes: new Uint8Array(),\n    address: new Long(0, 0, true),\n};\n\nexport const LOCATION_FIELD_ID = 't-mv-location';\nexport const LENGTH_FIELD_ID = 't-mv-length';\nexport const LOCATION_OFFSET_FIELD_ID = 't-mv-location-offset';\nexport const BYTES_PER_ROW_FIELD_ID = 't-mv-bytesrow';\nexport const BYTES_PER_GROUP_FIELD_ID = 't-mv-bytesgroup';\nexport const ENDIAN_SELECT_ID = 't-mv-endiannesss';\nexport const ASCII_TOGGLE_ID = 't-mv-ascii-toggle';\nexport const AUTO_UPDATE_TOGGLE_ID = 't-mv-auto-update-toggle';\n\n@injectable()\nexport class MemoryOptionsWidget extends ReactWidget implements StatefulWidget {\n    static ID = 'memory-view-options-widget';\n    static LABEL = 'Memory';\n    iconClass = 'memory-view-icon';\n    lockIconClass = 'memory-lock-icon';\n\n    static WIDGET_H2_CLASS = 'memory-widget-header';\n    static WIDGET_HEADER_INPUT_CLASS = 'memory-widget-header-input';\n\n    protected additionalColumnSelectLabel = 'Extra Column';\n\n    protected sessionListeners = new DisposableCollection();\n\n    protected readonly onOptionsChangedEmitter = new Emitter<string | undefined>();\n    readonly onOptionsChanged = this.onOptionsChangedEmitter.event;\n    protected readonly onMemoryChangedEmitter = new Emitter<Interfaces.MemoryReadResult>();\n    readonly onMemoryChanged = this.onMemoryChangedEmitter.event;\n    protected pinnedMemoryReadResult: Deferred<Interfaces.MemoryReadResult | false> | undefined;\n\n    protected memoryReadResult: Interfaces.MemoryReadResult = EMPTY_MEMORY;\n    protected columnsDisplayed: Interfaces.ColumnsDisplayed = {\n        address: { label: 'Address', doRender: true },\n        data: { label: 'Data', doRender: true },\n        variables: { label: 'Variables', doRender: true },\n        ascii: { label: 'ASCII', doRender: false },\n    };\n\n    protected byteSize = 8;\n\n    protected bytesPerGroup = 1;\n    protected groupsPerRow = 4;\n    protected variables: VariableRange[] = [];\n    protected endianness: Interfaces.Endianness = Interfaces.Endianness.Little;\n\n    protected memoryReadError = 'No memory contents currently available.';\n\n    protected address: string | number = 0;\n    protected offset = 0;\n    protected readLength = 256;\n    protected doDisplaySettings = false;\n    protected doUpdateAutomatically = true;\n    protected showMemoryError = false;\n    protected errorTimeout: NodeJS.Timeout | undefined = undefined;\n    protected addressField: HTMLInputElement | undefined;\n    protected offsetField: HTMLInputElement | undefined;\n    protected readLengthField: HTMLInputElement | undefined;\n    protected headerInputField: HTMLInputElement | undefined;\n    protected recentLocations = new Recents();\n    protected showTitleEditIcon = false;\n    protected isTitleEditable = false;\n\n    @inject(MemoryProvider) protected readonly memoryProvider: MemoryProvider;\n    @inject(DebugSessionManager) protected readonly sessionManager: DebugSessionManager;\n    @inject(MemoryWidgetOptions) protected readonly memoryWidgetOptions: MemoryWidgetOptions;\n\n    get memory(): Interfaces.WidgetMemoryState {\n        return {\n            ...this.memoryReadResult,\n            variables: this.variables,\n        };\n    }\n\n    get options(): Interfaces.MemoryOptions {\n        return this.storeState();\n    }\n\n    @postConstruct()\n    protected init(): void {\n        this.addClass(MemoryOptionsWidget.ID);\n\n        this.title.label = `Memory (${this.memoryWidgetOptions.displayId})`;\n        this.title.caption = `Memory (${this.memoryWidgetOptions.displayId})`;\n        this.title.iconClass = this.iconClass;\n        this.title.closable = true;\n\n        if (this.memoryWidgetOptions.dynamic !== false) {\n            this.toDispose.push(this.sessionManager.onDidChangeActiveDebugSession(({ current }) => {\n                this.setUpListeners(current);\n            }));\n\n            this.toDispose.push(this.sessionManager.onDidCreateDebugSession(current => {\n                this.setUpListeners(current);\n            }));\n            this.setUpListeners(this.sessionManager.currentSession);\n        }\n        this.toDispose.push(this.onOptionsChanged(() => this.update()));\n\n        this.update();\n    }\n\n    async setAddressAndGo(\n        newAddress: string,\n        newOffset?: number,\n        newLength?: number,\n        direction?: 'above' | 'below',\n    ): Promise<Interfaces.MemoryReadResult | false | undefined> {\n        let doUpdate = false;\n        const originalValues = {\n            offset: '',\n            length: '',\n        };\n        if (this.addressField) {\n            this.addressField.value = newAddress;\n            doUpdate = true;\n        }\n        if (this.offsetField && newOffset !== undefined) {\n            originalValues.offset = this.offsetField.value;\n            this.offsetField.value = newOffset.toString();\n            doUpdate = true;\n        }\n        if (this.readLengthField && newLength !== undefined) {\n            originalValues.length = this.readLengthField.value;\n            this.readLengthField.value = newLength.toString();\n            doUpdate = true;\n        }\n        if (doUpdate && this.readLengthField && this.offsetField) {\n            this.pinnedMemoryReadResult = new Deferred<Interfaces.MemoryReadResult>();\n            this.updateMemoryView();\n            const result = await this.pinnedMemoryReadResult.promise;\n            if (result === false) {\n                // Memory request errored\n                this.readLengthField.value = originalValues.length;\n                this.offsetField.value = originalValues.offset;\n            }\n            if (result) {\n                // Memory request returned some memory\n                const resultLength = result.bytes.length * 8 / this.byteSize;\n                const lengthFieldValue = parseInt(this.readLengthField.value);\n                if (lengthFieldValue !== resultLength) {\n                    this.memoryReadError = 'Memory bounds exceeded, result will be truncated.';\n                    this.doShowMemoryErrors();\n                    this.readLengthField.value = resultLength.toString();\n                    if (direction === 'above') {\n                        this.offsetField.value = `${parseInt(originalValues.offset) - (resultLength - parseInt(originalValues.length))}`;\n                    }\n                    this.update();\n                }\n            }\n        }\n        return undefined;\n    }\n\n    protected setUpListeners(session?: DebugSession): void {\n        this.sessionListeners.dispose();\n        this.sessionListeners = new DisposableCollection(Disposable.create(() => this.handleActiveSessionChange()));\n        if (session) {\n            this.sessionListeners.push(session.onDidChange(() => this.handleSessionChange()));\n        }\n    }\n\n    protected handleActiveSessionChange(): void {\n        const isDynamic = this.memoryWidgetOptions.dynamic !== false;\n        if (isDynamic && this.doUpdateAutomatically) {\n            this.memoryReadResult = EMPTY_MEMORY;\n            this.fireDidChangeMemory();\n        }\n    }\n\n    protected handleSessionChange(): void {\n        const isStopped = this.sessionManager.currentSession?.state === DebugState.Stopped;\n        const isReadyForQuery = !!this.sessionManager.currentSession?.currentFrame;\n        const isDynamic = this.memoryWidgetOptions.dynamic !== false;\n        if (isStopped && isReadyForQuery && isDynamic && this.doUpdateAutomatically && this.memoryReadResult !== EMPTY_MEMORY) {\n            this.updateMemoryView();\n        }\n    }\n\n    protected onActivateRequest(msg: Message): void {\n        super.onActivateRequest(msg);\n        this.acceptFocus();\n    }\n\n    protected acceptFocus(): void {\n        if (this.doUpdateAutomatically) {\n            if (this.addressField) {\n                this.addressField.focus();\n                this.addressField.select();\n            }\n        } else {\n            const settingsCog = this.node.querySelector('.toggle-settings-click-zone') as HTMLDivElement;\n            settingsCog?.focus();\n        }\n    }\n\n    protected handleColumnSelectionChange = (columnLabel: string, doShow: boolean): void => this.doHandleColumnSelectionChange(columnLabel, doShow);\n\n    protected doHandleColumnSelectionChange(columnLabel: string, doShow: boolean): void {\n        if (columnLabel in this.columnsDisplayed) {\n            this.columnsDisplayed[columnLabel].doRender = doShow;\n            this.fireDidChangeOptions(ASCII_TOGGLE_ID);\n        }\n    }\n\n    protected toggleAutoUpdate = (e: React.MouseEvent<HTMLDivElement> | React.KeyboardEvent<HTMLDivElement>): void => {\n        if (e.nativeEvent.type === 'click') {\n            e.currentTarget.blur();\n        }\n        if ('key' in e && e.keyCode === Key.TAB.keyCode) {\n            return;\n        }\n        this.doUpdateAutomatically = !this.doUpdateAutomatically;\n        if (this.doUpdateAutomatically) {\n            this.title.iconClass = this.iconClass;\n        } else {\n            this.title.iconClass = this.lockIconClass;\n        }\n        this.fireDidChangeOptions();\n    };\n\n    protected onByteSizeChange = (event: React.ChangeEvent<HTMLSelectElement>): void => {\n        this.byteSize = parseInt(event.target.value);\n        this.fireDidChangeOptions(event.target.id);\n    };\n\n    protected onAfterAttach(msg: Message): void {\n        super.onAfterAttach(msg);\n        if (this.memoryWidgetOptions.dynamic !== false) {\n            if (this.addressField) {\n                this.addressField.value = this.address.toString();\n            }\n        }\n    }\n\n    protected toggleDoShowSettings = (e: React.MouseEvent<HTMLDivElement> | React.KeyboardEvent<HTMLDivElement>): void => {\n        if (!('key' in e) || e.keyCode !== Key.TAB.keyCode) {\n            this.doDisplaySettings = !this.doDisplaySettings;\n            this.update();\n        }\n    };\n\n    protected render(): React.ReactNode {\n        return (\n            <div className='t-mv-container'>\n                {this.renderInputContainer()}\n            </div>\n        );\n    }\n\n    protected renderInputContainer(): React.ReactNode {\n        return (\n            <div className='t-mv-settings-container'>\n                <div className='t-mv-wrapper'>\n                    {this.renderToolbar()}\n                    {this.renderMemoryLocationGroup()}\n                    {this.doDisplaySettings && (\n                        <div className='t-mv-toggle-settings-wrapper'>\n                            {this.renderByteDisplayGroup()}\n                        </div>\n                    )}\n                </div>\n            </div>\n        );\n    }\n\n    // eslint-disable-next-line max-lines-per-function\n    protected renderByteDisplayGroup(): React.ReactNode {\n        return (\n            <div className='t-mv-group settings-group'>\n                <MWSelect\n                    id='byte-size-select'\n                    label='Byte Size'\n                    value={this.byteSize.toString()}\n                    onChange={this.onByteSizeChange}\n                    options={['8', '16', '32', '64']}\n                />\n                <MWSelect\n                    id={BYTES_PER_GROUP_FIELD_ID}\n                    label='Bytes Per Group'\n                    value={this.bytesPerGroup.toString()}\n                    onChange={this.onBytesPerGroupChange}\n                    options={['1', '2', '4', '8', '16']}\n                />\n                <MWSelect\n                    id={BYTES_PER_ROW_FIELD_ID}\n                    label='Groups Per Row'\n                    value={this.groupsPerRow.toString()}\n                    onChange={this.onGroupsPerRowChange}\n                    options={['1', '2', '4', '8', '16', '32']}\n                />\n                <MWSelect\n                    id={ENDIAN_SELECT_ID}\n                    label='Endianness'\n                    value={this.endianness}\n                    onChange={this.onEndiannessChange}\n                    options={[Interfaces.Endianness.Little, Interfaces.Endianness.Big]}\n                />\n                <MWMultiSelect\n                    id={ASCII_TOGGLE_ID}\n                    label='Columns'\n                    items={this.getOptionalColumns()}\n                    onSelectionChanged={this.handleColumnSelectionChange}\n                />\n            </div>\n        );\n    }\n\n    protected getObligatoryColumnIds(): string[] {\n        return ['address', 'data'];\n    }\n\n    protected getOptionalColumns(): SingleSelectItemProps[] {\n        const obligatoryColumns = new Set(this.getObligatoryColumnIds());\n        return Object.entries(this.columnsDisplayed)\n            .reduce<SingleSelectItemProps[]>((accumulated, [id, { doRender, label }]) => {\n                if (!obligatoryColumns.has(id)) {\n                    accumulated.push({ id, label, defaultChecked: doRender });\n                }\n                return accumulated;\n            }, []);\n    }\n\n    protected assignLocationRef: React.LegacyRef<HTMLInputElement> = location => {\n        this.addressField = location ?? undefined;\n    };\n\n    protected assignReadLengthRef: React.LegacyRef<HTMLInputElement> = readLength => {\n        this.readLengthField = readLength ?? undefined;\n    };\n\n    protected assignOffsetRef: React.LegacyRef<HTMLInputElement> = offset => {\n        this.offsetField = offset ?? undefined;\n    };\n\n    protected setAddressFromSelect = (e: React.ChangeEvent<HTMLSelectElement>): void => {\n        if (this.addressField) {\n            this.addressField.value = e.target.value;\n        }\n    };\n\n    // eslint-disable-next-line max-lines-per-function\n    protected renderMemoryLocationGroup(): React.ReactNode {\n        return (\n            <>\n                <div className='t-mv-group view-group'>\n                    <MWInputWithSelect\n                        id={LOCATION_FIELD_ID}\n                        label='Address'\n                        title='Memory location to display, an address or expression evaluating to an address'\n                        defaultValue={`${this.address}`}\n                        onSelectChange={this.setAddressFromSelect}\n                        passRef={this.assignLocationRef}\n                        onKeyDown={this.doRefresh}\n                        options={[...this.recentLocations.values]}\n                        disabled={!this.doUpdateAutomatically}\n                    />\n                    <MWInput\n                        id={LOCATION_OFFSET_FIELD_ID}\n                        label='Offset'\n                        title='Offset to be added to the current memory location, when navigating'\n                        defaultValue='0'\n                        passRef={this.assignOffsetRef}\n                        onKeyDown={this.doRefresh}\n                        disabled={!this.doUpdateAutomatically}\n                    />\n                    <MWInput\n                        id={LENGTH_FIELD_ID}\n                        label='Length'\n                        title='Number of bytes to fetch, in decimal or hexadecimal'\n                        defaultValue={this.readLength.toString()}\n                        passRef={this.assignReadLengthRef}\n                        onChange={Utils.validateNumericalInputs}\n                        onKeyDown={this.doRefresh}\n                        disabled={!this.doUpdateAutomatically}\n                    />\n                    <button\n                        type='button'\n                        className='theia-button main view-group-go-button'\n                        onClick={this.doRefresh}\n                        disabled={!this.doUpdateAutomatically}\n                    >\n                        Go\n                    </button>\n                </div>\n                <div className={`t-mv-memory-fetch-error${this.showMemoryError ? ' show' : ' hide'}`}>\n                    {this.memoryReadError}\n                </div>\n            </>\n        );\n    }\n\n    protected activateHeaderInputField = (e: React.MouseEvent<HTMLDivElement> | React.KeyboardEvent<HTMLDivElement>): void => {\n        if (!this.isTitleEditable) {\n            const isMouseDown = !('key' in e);\n            const isActivationKey = 'key' in e && (e.keyCode === Key.SPACE.keyCode || e.keyCode === Key.ENTER.keyCode);\n            if (isMouseDown || isActivationKey) {\n                if (isMouseDown) {\n                    e.currentTarget.blur();\n                }\n                this.isTitleEditable = true;\n                this.update();\n            }\n        }\n    };\n\n    protected saveHeaderInputValue = (e: React.MouseEvent<HTMLDivElement> | React.KeyboardEvent<HTMLDivElement>): void => {\n        const isMouseDown = !('key' in e);\n        const isSaveKey = 'key' in e && e.key === 'Enter';\n        const isCancelKey = 'key' in e && e.key === 'Escape';\n        e.stopPropagation();\n        if (isMouseDown || isSaveKey || isCancelKey) {\n            if (!isCancelKey && this.headerInputField) {\n                this.title.label = this.headerInputField.value;\n                this.title.caption = this.headerInputField.value;\n            }\n\n            this.isTitleEditable = false;\n            this.update();\n        }\n    };\n\n    protected assignHeaderInputRef = (element: HTMLInputElement): void => {\n        if (element) {\n            this.headerInputField = element;\n            element.focus();\n        }\n    };\n\n    protected renderToolbar(): React.ReactNode {\n        return (\n            <div className='memory-widget-toolbar'>\n                {this.memoryWidgetOptions.dynamic !== false && (\n                    <div className='memory-widget-auto-updates-container'>\n                        <div\n                            className={`fa fa-${this.doUpdateAutomatically ? 'unlock' : 'lock'}`}\n                            id={AUTO_UPDATE_TOGGLE_ID}\n                            title={this.doUpdateAutomatically ? 'Freeze memory view' : 'Unfreeze memory view'}\n                            onClick={this.toggleAutoUpdate}\n                            onKeyDown={this.toggleAutoUpdate}\n                            role='button'\n                            tabIndex={0}\n                        />\n                    </div>\n                )}\n                {this.renderEditableTitleField()}\n                <div\n                    className='toggle-settings-container'\n                >\n                    <div\n                        className='toggle-settings-click-zone'\n                        tabIndex={0}\n                        aria-label={`${this.doDisplaySettings ? 'Hide settings panel' : 'Show settings panel'}`}\n                        role='button'\n                        onClick={this.toggleDoShowSettings}\n                        onKeyDown={this.toggleDoShowSettings}\n                        title={`${this.doDisplaySettings ? 'Hide settings panel' : 'Show settings panel'}`}\n                    >\n                        <i className='codicon codicon-settings-gear' />\n                        <span>{this.doDisplaySettings ? 'Close Settings' : 'Settings'}</span>\n                    </div>\n                </div>\n            </div>\n        );\n    }\n\n    protected renderEditableTitleField(): React.ReactNode {\n        return (\n            <div\n                className='memory-widget-header-click-zone'\n                tabIndex={0}\n                onClick={this.activateHeaderInputField}\n                onKeyDown={this.activateHeaderInputField}\n                role='button'\n            >\n                {!this.isTitleEditable\n                    ? (\n                        <h2 className={`memory-widget-header${!this.doUpdateAutomatically ? ' disabled' : ''}`}>\n                            {this.title.label}\n                        </h2>\n                    )\n                    : <input\n                        className='theia-input'\n                        type='text'\n                        defaultValue={this.title.label}\n                        onKeyDown={this.saveHeaderInputValue}\n                        spellCheck={false}\n                        ref={this.assignHeaderInputRef}\n                    />}\n                {!this.isTitleEditable && (\n                    <div\n                        className={`fa fa-pencil${this.showTitleEditIcon ? ' show' : ' hide'}`}\n                    />\n                )}\n                {this.isTitleEditable && (\n                    <div\n                        className='fa fa-save'\n                        onClick={this.saveHeaderInputValue}\n                        onKeyDown={this.saveHeaderInputValue}\n                        role='button'\n                        tabIndex={0}\n                    />\n                )}\n            </div>\n        );\n    }\n\n    storeState(): Interfaces.MemoryOptions {\n        return {\n            address: this.addressField?.value ?? this.address,\n            offset: parseInt(`${this.offsetField?.value}`) ?? this.offset,\n            length: parseInt(`${this.readLengthField?.value}`) ?? this.readLength,\n            byteSize: this.byteSize,\n            bytesPerGroup: this.bytesPerGroup,\n            groupsPerRow: this.groupsPerRow,\n            endianness: this.endianness,\n            doDisplaySettings: this.doDisplaySettings,\n            columnsDisplayed: this.columnsDisplayed,\n            recentLocationsArray: this.recentLocations.values,\n            isFrozen: !this.doUpdateAutomatically,\n            doUpdateAutomatically: this.doUpdateAutomatically,\n        };\n    }\n\n    restoreState(oldState: Interfaces.MemoryOptions): void {\n        this.address = oldState.address ?? this.address;\n        this.offset = oldState.offset ?? this.offset;\n        this.readLength = oldState.length ?? this.readLength;\n        this.byteSize = oldState.byteSize ?? this.byteSize;\n        this.bytesPerGroup = oldState.bytesPerGroup ?? this.bytesPerGroup;\n        this.groupsPerRow = oldState.groupsPerRow ?? this.groupsPerRow;\n        this.endianness = oldState.endianness ?? this.endianness;\n        this.recentLocations = new Recents(oldState.recentLocationsArray) ?? this.recentLocations;\n        this.doDisplaySettings = !!oldState.doDisplaySettings;\n        if (oldState.columnsDisplayed) {\n            this.columnsDisplayed = oldState.columnsDisplayed;\n        }\n    }\n\n    protected doShowMemoryErrors = (doClearError = false): void => {\n        if (this.errorTimeout !== undefined) {\n            clearTimeout(this.errorTimeout);\n        }\n        if (doClearError) {\n            this.showMemoryError = false;\n            this.update();\n            this.errorTimeout = undefined;\n            return;\n        }\n        this.showMemoryError = true;\n        this.update();\n        this.errorTimeout = setTimeout(() => {\n            this.showMemoryError = false;\n            this.update();\n            this.errorTimeout = undefined;\n        }, Constants.ERROR_TIMEOUT);\n    };\n\n    protected doRefresh = (event: React.KeyboardEvent<HTMLInputElement> | React.MouseEvent<HTMLButtonElement, MouseEvent>): void => {\n        if ('key' in event && event.key !== 'Enter') {\n            return;\n        }\n        this.updateMemoryView();\n    };\n\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n    protected updateMemoryView = debounce(this.doUpdateMemoryView.bind(this), Constants.DEBOUNCE_TIME, { trailing: true });\n\n    protected async doUpdateMemoryView(): Promise<void> {\n        if (!(this.addressField && this.readLengthField)) { return; }\n\n        if (!(this.addressField?.value.length > 0)) {\n            this.memoryReadError = 'Enter an address or expression in the Location field.';\n            this.update();\n            return;\n        }\n        if (this.readLengthField.value.length === 0) {\n            this.memoryReadError = 'Enter a length (decimal or hexadecimal number) in the Length field.';\n            this.update();\n            return;\n        }\n\n        const startAddress = this.addressField.value;\n        const locationOffset = parseInt(`${this.offsetField?.value}`) || 0;\n        const readLength = parseInt(this.readLengthField.value);\n\n        try {\n            this.memoryReadResult = await this.getMemory(startAddress, readLength, locationOffset);\n            this.fireDidChangeMemory();\n            if (this.pinnedMemoryReadResult) {\n                this.pinnedMemoryReadResult.resolve(this.memoryReadResult);\n            }\n            this.doShowMemoryErrors(true);\n        } catch (err) {\n            this.memoryReadError = 'There was an error fetching memory with specified address length.';\n            console.error('Failed to read memory', err);\n            this.doShowMemoryErrors();\n            if (this.pinnedMemoryReadResult) {\n                this.pinnedMemoryReadResult.resolve(this.memoryReadResult);\n            }\n        } finally {\n            this.pinnedMemoryReadResult = undefined;\n            this.update();\n        }\n    }\n\n    protected async getMemory(startAddress: string, readLength: number, locationOffset: number): Promise<Interfaces.MemoryReadResult> {\n        const result = await this.memoryProvider.readMemory(startAddress, readLength, locationOffset); // .catch(() => toMockMemoryRead());\n        this.variables = await getLocals(this.sessionManager.currentSession);\n        this.recentLocations.add(startAddress);\n        this.updateDefaults(startAddress, readLength, locationOffset);\n        return result;\n    }\n\n    // TODO: This may not be necessary if we change how state is stored (currently in the text fields themselves.)\n    protected updateDefaults(address: string, readLength: number, offset: number): void {\n        this.address = address;\n        this.readLength = readLength;\n        this.offset = offset;\n    }\n\n    // Callbacks for when the various view parameters change.\n    /**\n     * Handle bytes per row changed event.\n     */\n    protected onGroupsPerRowChange = (event: React.ChangeEvent<HTMLInputElement>): void => {\n        const { value, id } = event.target;\n        this.groupsPerRow = parseInt(value);\n        this.fireDidChangeOptions(id);\n    };\n\n    /**\n     * Handle bytes per group changed event.\n     */\n    protected onBytesPerGroupChange = (event: React.ChangeEvent<HTMLSelectElement>): void => {\n        const { value, id } = event.target;\n        this.bytesPerGroup = parseInt(value);\n        this.fireDidChangeOptions(id);\n    };\n\n    /**\n     * Handle endianness changed event.\n     */\n    protected onEndiannessChange = (event: React.ChangeEvent<HTMLSelectElement>): void => {\n        const { value, id } = event.target;\n        if (value !== Interfaces.Endianness.Big && value !== Interfaces.Endianness.Little) { return; }\n        this.endianness = value;\n        this.fireDidChangeOptions(id);\n    };\n\n    protected fireDidChangeOptions(targetId?: string): void {\n        this.onOptionsChangedEmitter.fire(targetId);\n    }\n\n    protected fireDidChangeMemory(): void {\n        this.onMemoryChangedEmitter.fire(this.memoryReadResult);\n    }\n}\n","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/memory-widget/memory-table-widget.tsx",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/memory-widget/memory-widget.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/register-widget/register-filter-service.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/register-widget/register-options-widget.tsx",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/register-widget/register-table-widget.tsx",["138"],"/********************************************************************************\n * Copyright (C) 2021 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport * as React from 'react';\nimport { Key } from '@theia/core/lib/browser';\nimport { DebugVariable } from '@theia/debug/lib/browser/console/debug-console-items';\nimport { inject, postConstruct } from 'inversify';\nimport { MemoryTableWidget, MemoryTable } from '../memory-widget/memory-table-widget';\nimport { RegisterReadResult } from '../utils/memory-widget-variable-utils';\nimport { RegisterOptions, RegisterOptionsWidget } from './register-options-widget';\n\nexport namespace RegisterTable {\n\n    export const ROW_CLASS = 't-mv-view-row';\n    export const ROW_DIVIDER_CLASS = 't-mv-view-row-highlight';\n    export const REGISTER_NAME_CLASS = 't-mv-view-address';\n    export const REGISTER_DATA_CLASS = 't-mv-view-data';\n    export const EXTRA_COLUMN_DATA_CLASS = 't-mv-view-code';\n    export const HEADER_ROW_CLASS = 't-mv-header';\n\n    export interface RowOptions {\n        regName: string;\n        regVal: string;\n        hexadecimal?: string;\n        decimal?: string;\n        octal?: string;\n        binary?: string;\n        doShowDivider?: boolean;\n        isChanged?: boolean;\n    }\n\n    export interface StylableNodeAttributes {\n        className?: string;\n        style?: React.CSSProperties;\n        title?: string;\n        isChanged?: boolean;\n    }\n\n    export interface RowDecorator {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (...args: any[]): Partial<StylableNodeAttributes>;\n    }\n}\n\nexport class RegisterTableWidget extends MemoryTableWidget {\n    static CONTEXT_MENU = ['register.view.context.menu'];\n    static ID = 'register-table-widget';\n\n    @inject(RegisterOptionsWidget) readonly optionsWidget: RegisterOptionsWidget;\n\n    protected readonly registerNotSaved = '<not saved>';\n    protected registers: RegisterReadResult;\n    protected previousRegisters: RegisterReadResult | undefined;\n    protected options: RegisterOptions;\n\n    @postConstruct() /* eslint-disable-line @typescript-eslint/require-await */ // extenders may want real async\n    protected async init(): Promise<void> {\n        this.id = RegisterTableWidget.ID;\n        this.addClass(RegisterTableWidget.ID);\n        this.scrollOptions = { ...this.scrollOptions, suppressScrollX: false };\n        this.toDispose.push(this.optionsWidget.onOptionsChanged(optionId => this.handleOptionChange(optionId)));\n        this.toDispose.push(this.optionsWidget.onRegisterChanged(e => this.handleRegisterChange(e)));\n        this.toDispose.push(this.themeService.onThemeChange(e => this.handleThemeChange(e)));\n\n        this.getStateAndUpdate();\n    }\n\n    handleSetValue(dVar: DebugVariable | undefined): void {\n        if (dVar) {\n            dVar.open();\n        }\n    }\n\n    protected handleRegisterChange(newRegister: [RegisterReadResult, boolean]): void {\n        const regResult = newRegister[0];\n        const updatePrevRegs = !newRegister[1];\n        if (this.registers.threadId !== regResult.threadId) {\n            // if not same thread Id, dont highlighting register changes\n            this.previousRegisters = undefined;\n        } else {\n            if (updatePrevRegs) {\n                this.previousRegisters = this.registers;\n            }\n        }\n        this.getStateAndUpdate();\n    }\n\n    protected getState(): void {\n        this.options = this.optionsWidget.options;\n        this.registers = this.optionsWidget.registers;\n    }\n\n    protected getTableRows(): React.ReactNode {\n        return [...this.renderRegRows()];\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected *renderRegRows(result: RegisterReadResult = this.registers): IterableIterator<React.ReactNode> {\n        let rowsYielded = 0;\n        // For each row...\n        for (const reg of result.registers) {\n            if (this.optionsWidget.displayReg(reg.name)) {\n                const notSaved = reg.value === this.registerNotSaved;\n                const isChanged = this.previousRegisters && reg.value !== this.getPrevRegVal(reg.name, this.previousRegisters);\n                const options: RegisterTable.RowOptions = {\n                    regName: reg.name,\n                    regVal: reg.value,\n                    hexadecimal: notSaved ? reg.value : this.optionsWidget.handleRadixRendering(reg.value, 16, reg.name),\n                    decimal: notSaved ? reg.value : this.optionsWidget.handleRadixRendering(reg.value, 10),\n                    octal: notSaved ? reg.value : this.optionsWidget.handleRadixRendering(reg.value, 8),\n                    binary: notSaved ? reg.value : this.optionsWidget.handleRadixRendering(reg.value, 2, reg.name),\n                    doShowDivider: (rowsYielded % 4) === 3,\n                    isChanged,\n                };\n                yield this.renderRegRow(options);\n                rowsYielded += 1;\n            }\n        }\n    }\n\n    protected getPrevRegVal(regName: string, inRegs: RegisterReadResult): string | undefined {\n        return inRegs.registers.find(element => element.name === regName)?.value;\n    }\n\n    protected renderRegRow(\n        options: RegisterTable.RowOptions,\n        getRowAttributes: RegisterTable.RowDecorator = this.getRowAttributes.bind(this),\n    ): React.ReactNode {\n        const { regName } = options;\n        const { className, style, title } = getRowAttributes(options);\n        return (\n            <tr\n                // Add a marker to help visual navigation when scrolling\n                className={className}\n                style={style}\n                title={title}\n                key={regName}\n                data-id={regName}\n                data-value={options.decimal ?? 'none'}\n                tabIndex={0}\n                onKeyDown={this.handleRowKeyDown}\n                onContextMenu={this.options.isFrozen ? undefined : this.handleTableRightClick}\n                onDoubleClick={this.options.isFrozen ? undefined : this.openDebugVariableByCurrentTarget}\n            >\n                <td className={RegisterTable.REGISTER_NAME_CLASS}>{regName}</td>\n                {this.getExtraRegColumn(options)}\n            </tr>\n        );\n    }\n\n    protected getRowAttributes(options: Partial<RegisterTable.RowOptions>): Partial<RegisterTable.StylableNodeAttributes> {\n        let className = RegisterTable.ROW_CLASS;\n        if (options.doShowDivider) {\n            className += ` ${RegisterTable.ROW_DIVIDER_CLASS}`;\n        }\n        if (options.isChanged) {\n            // use the eight-bits change CSS class\n            className += ' eight-bits changed';\n        }\n        return { className };\n    }\n\n    protected getExtraRegColumn(options: Pick<RegisterTable.RowOptions, 'hexadecimal' | 'decimal' | 'octal' | 'binary'>): React.ReactNodeArray {\n        const additionalColumns = [];\n        if (this.options.columnsDisplayed.hexadecimal.doRender) {\n            additionalColumns.push(<td className={RegisterTable.EXTRA_COLUMN_DATA_CLASS} key='hexadecimal'>{options.hexadecimal}</td>);\n        }\n        if (this.options.columnsDisplayed.decimal.doRender) {\n            additionalColumns.push(<td className={RegisterTable.EXTRA_COLUMN_DATA_CLASS} key='decimal'>{options.decimal}</td>);\n        }\n        if (this.options.columnsDisplayed.octal.doRender) {\n            additionalColumns.push(<td className={RegisterTable.EXTRA_COLUMN_DATA_CLASS} key='octal'>{options.octal}</td>);\n        }\n        if (this.options.columnsDisplayed.binary.doRender) {\n            additionalColumns.push(<td className={RegisterTable.EXTRA_COLUMN_DATA_CLASS} key='binary'>{options.binary}</td>);\n        }\n\n        return additionalColumns;\n    }\n\n    protected getWrapperHandlers(): MemoryTable.WrapperHandlers {\n        return this.options.isFrozen || this.options.noRadixColumnDisplayed\n            ? super.getWrapperHandlers()\n            : {\n                onMouseMove: this.handleTableMouseMove,\n                onContextMenu: this.handleTableRightClick,\n            };\n    }\n\n    protected doHandleTableMouseMove(targetElement: React.MouseEvent['target']): void {\n        const tempTarget = targetElement as HTMLElement;\n        const target = tempTarget.parentElement?.tagName === 'TR' ? tempTarget.parentElement : tempTarget;\n        if (target.tagName === 'TR') {\n            const { x, y } = target.getBoundingClientRect();\n            const anchor = { x: Math.round(x), y: Math.round(y + target.clientHeight) };\n            const value = Number(target.getAttribute('data-value'));\n            if (!isNaN(value)) {\n                const register = target.getAttribute('data-id') as string;\n                const properties = {\n                    register,\n                    hex: `0x${value.toString(16)}`,\n                    binary: `0b${value.toString(2)}`,\n                    decimal: value.toString(10),\n                    octal: `0o${value.toString(8)}`,\n                };\n                return this.hoverRenderer.render(this.node, anchor, properties);\n            }\n        }\n        return this.hoverRenderer.hide();\n    }\n\n    private handleRowKeyDown = (event: React.KeyboardEvent<HTMLElement>): void => {\n        const { keyCode } = event;\n        switch (keyCode) {\n            case Key.ENTER.keyCode:\n                this.openDebugVariableByCurrentTarget(event);\n                break;\n            default:\n                break;\n        }\n    };\n\n    protected openDebugVariableByCurrentTarget = (event: React.KeyboardEvent<HTMLElement> | React.MouseEvent<HTMLElement>): void => {\n        this.openDebugVariableByDataId(event.currentTarget);\n    };\n\n    protected openDebugVariableByDataId(element: HTMLElement): void {\n        const registerName = element.getAttribute('data-id');\n        if (registerName) {\n            this.openDebugVariableByName(registerName);\n        }\n    }\n\n    protected openDebugVariableByName(registerName: string): void {\n        const debugVariable = this.registers.registers.find(element => element.name === registerName);\n        this.handleSetValue(debugVariable);\n    }\n\n    protected doHandleTableRightClick(event: React.MouseEvent): void {\n        const curTarget = event.currentTarget as HTMLElement;\n        if (curTarget.tagName === 'TR') {\n            this.update();\n            event.stopPropagation();\n            this.contextMenuRenderer.render({\n                menuPath: RegisterTableWidget.CONTEXT_MENU,\n                anchor: event.nativeEvent,\n                args: this.getContextMenuArgs(event),\n            });\n        }\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected getContextMenuArgs(event: React.MouseEvent): any[] {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const args: any[] = [this];\n        const regName = (event.currentTarget as HTMLElement).getAttribute('data-id');\n        if (regName) {\n            const dVar = this.registers.registers.find(element => element.name === regName);\n            args.push(dVar);\n        }\n        return args;\n    }\n}\n","/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/register-widget/register-widget-types.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-commands.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-hover-renderer.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-recents.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-widget-components.tsx",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-widget-manager.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-widget-utils.tsx",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/memory-widget-variable-utils.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/utils/multi-select-bar.tsx",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/wrapper-widgets/memory-dock-panel.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/wrapper-widgets/memory-dockpanel-placeholder-widget.tsx",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/browser/wrapper-widgets/memory-layout-widget.tsx",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/common/util.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/common/utils.spec.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/node/cpp-debug-backend-contribution.ts",[],"/home/eugen/Git/theia-blueprint-cdt/cpp-extensions/cpp-debug/packages/cpp-debug/src/node/cpp-debug-backend-module.ts",[],{"ruleId":"139","severity":1,"message":"140","line":117,"column":37,"nodeType":"141","messageId":"142","endLine":117,"endColumn":44},{"ruleId":"139","severity":1,"message":"140","line":114,"column":15,"nodeType":"141","messageId":"142","endLine":114,"endColumn":22},{"ruleId":"139","severity":1,"message":"140","line":238,"column":17,"nodeType":"141","messageId":"142","endLine":238,"endColumn":24},{"ruleId":"139","severity":1,"message":"140","line":246,"column":29,"nodeType":"141","messageId":"142","endLine":246,"endColumn":36},{"ruleId":"139","severity":1,"message":"140","line":273,"column":32,"nodeType":"141","messageId":"142","endLine":273,"endColumn":39},{"ruleId":"139","severity":1,"message":"140","line":432,"column":54,"nodeType":"141","messageId":"142","endLine":432,"endColumn":61},{"ruleId":"139","severity":1,"message":"140","line":432,"column":89,"nodeType":"141","messageId":"142","endLine":432,"endColumn":96},{"ruleId":"139","severity":1,"message":"140","line":226,"column":17,"nodeType":"141","messageId":"142","endLine":226,"endColumn":24},"deprecation/deprecation","'keyCode' is deprecated. ","Identifier","deprecated"]